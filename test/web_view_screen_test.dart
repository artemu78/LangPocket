import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:LangPocket/screens/web_view_screen.dart'; // Adjust with your actual project name
import 'package:LangPocket/services/local_log_service.dart'; // Adjust with your actual project name

// Generate mocks for InAppWebViewController and LocalLogService
// Run `flutter pub run build_runner build` to generate these files
// If build_runner is not set up, you can create manual mocks as below for now.
@GenerateMocks([InAppWebViewController, LocalLogService])
import 'web_view_screen_test.mocks.dart'; // Generated by Mockito

// Manual mock for InAppWebViewController if build_runner is not used immediately
class MockInAppWebViewControllerManual extends Mock implements InAppWebViewController {
  @override
  Future<void> loadUrl({required URLRequest urlRequest}) async {
    // Allow capturing arguments or defining behavior
    super.noSuchMethod(
      Invocation.method(#loadUrl, [], {#urlRequest: urlRequest}),
      returnValue: Future.value(null),
      returnValueForMissingStub: Future.value(null)
    );
  }
}

// Manual mock for LocalLogService
class MockLocalLogServiceManual extends Mock implements LocalLogService {
  // Keep the existing log method if it's used elsewhere, or adjust to addLog
  @override
  void log(String message) { // This is from the old LocalLogService interface
    super.noSuchMethod(
      Invocation.method(#log, [message]),
      returnValueForMissingStub: null,
    );
  }

  // Add addLog for the new interface used in WebViewScreen
  @override
  void addLog(String level, String message) {
    super.noSuchMethod(
      Invocation.method(#addLog, [level, message]),
      returnValueForMissingStub: null,
    );
  }
}

// Manual mock for CookieManager
class MockCookieManager extends Mock implements CookieManager {
  @override
  Future<bool> setCookie({
    required WebUri url,
    required String name,
    required String value,
    String path = "/",
    String? domain,
    int? expiresDate,
    int? maxAge,
    bool? isSecure,
    bool? isHttpOnly,
    SameSite? sameSite,
  }) async {
    return super.noSuchMethod(
      Invocation.method(#setCookie, [], {
        #url: url,
        #name: name,
        #value: value,
        #path: path,
        #domain: domain,
        #expiresDate: expiresDate,
        #maxAge: maxAge,
        #isSecure: isSecure,
        #isHttpOnly: isHttpOnly,
        #sameSite: sameSite,
      }),
      returnValue: Future.value(true), // Default to true for successful set
      returnValueForMissingStub: Future.value(true),
    );
  }
}


void main() {
  TestWidgetsFlutterBinding.ensureInitialized(); // Ensure binding is initialized

  late MockInAppWebViewController mockWebViewController;
  late MockLocalLogServiceManual mockLogService; // Use the manual mock for LocalLogService
  // late MockCookieManager mockCookieManager; // Instance for CookieManager

  setUp(() {
    mockWebViewController = MockInAppWebViewController();
    mockLogService = MockLocalLogServiceManual();
    // mockCookieManager = MockCookieManager();

    // WebViewScreen instantiates its own LocalLogService.
    // To verify log calls, WebViewScreen would need to accept LocalLogService via constructor.
    // For CookieManager, it uses CookieManager.instance(). Mocking this static getter
    // is complex without library support for it (like `CookieManager.instance = mockCookieManager;`)
    // which flutter_inappwebview does not seem to offer directly for tests.

    when(mockWebViewController.loadUrl(urlRequest: anyNamed('urlRequest')))
        .thenAnswer((_) async {});
  });

  // Helper function to pump the widget
  Future<void> pumpWebViewScreen(WidgetTester tester, {LocalLogService? logService}) async {
    await tester.pumpWidget(MaterialApp(
      // If WebViewScreen were refactored to take LocalLogService or CookieManager:
      // home: WebViewScreen(logService: logService ?? MockLocalLogServiceManual()),
      home: WebViewScreen(), // Current implementation
    ));
    await tester.pumpAndSettle();
  }

  testWidgets('Initial UI Rendering (including Cookie TextField)', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    expect(find.text('Web View'), findsOneWidget, reason: "AppBar title should be 'Web View'");
    expect(find.widgetWithText(TextField, 'Enter URL'), findsOneWidget, reason: "URL input TextField should be present"); // Checks for the main URL field
    expect(find.widgetWithText(ElevatedButton, 'Go'), findsOneWidget, reason: "'Go' button should be present");
    expect(find.widgetWithText(ElevatedButton, 'Add Header'), findsOneWidget, reason: "'Add Header' button should be present");
    expect(find.byType(InAppWebView), findsOneWidget, reason: "InAppWebView widget should be present");

    // Verify Cookie TextField presence
    expect(find.widgetWithText(TextField, 'Enter cookie values (e.g., name1=value1; name2=value2)'), findsOneWidget, reason: "Cookie input TextField should be present");
  });

  testWidgets('Entering text in Cookie TextField updates its controller', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    final cookieFieldFinder = find.widgetWithText(TextField, 'Enter cookie values (e.g., name1=value1; name2=value2)');
    expect(cookieFieldFinder, findsOneWidget);

    await tester.enterText(cookieFieldFinder, 'user=test; token=abc');
    await tester.pumpAndSettle();

    final textField = tester.widget<TextField>(cookieFieldFinder);
    expect(textField.controller?.text, 'user=test; token=abc');
  });

  testWidgets('URL Input, Cookie Input, and Go button action - verifying logs for cookie setting', (WidgetTester tester) async {
    // Since LocalLogService is not injected, we cannot directly verify calls on a mock.
    // This test will check if the "Go" button press triggers the expected LOG flow for cookies.
    // This is an indirect verification. For robust testing, LocalLogService should be injectable.

    await pumpWebViewScreen(tester); // Not passing mockLogService as it's not injectable yet

    final urlField = find.widgetWithText(TextField, 'Enter URL'); // Main URL field
    await tester.enterText(urlField, 'https://secure.example.com');

    final cookieField = find.widgetWithText(TextField, 'Enter cookie values (e.g., name1=value1; name2=value2)');
    await tester.enterText(cookieField, 'mycookie=myvalue; another=otherval');

    await tester.tap(find.widgetWithText(ElevatedButton, 'Go'));
    await tester.pumpAndSettle(); // Allow futures in _go() to complete

    // **Conceptual Verification (if LocalLogService were injectable):**
    // verify(mockLogService.addLog('VERBOSE', 'Setting cookie: mycookie=myvalue for domain secure.example.com')).called(1);
    // verify(mockLogService.addLog('VERBOSE', 'Setting cookie: another=otherval for domain secure.example.com')).called(1);
    // verify(mockLogService.addLog('INFO', 'Navigating to: https://secure.example.com with headers: {User-Agent: LangPocketWebView/1.0}')).called(1);

    // As direct verification of log calls is not possible without refactoring WebViewScreen,
    // this test primarily ensures that:
    // 1. The "Go" button is tappable with URL and cookie inputs.
    // 2. The app doesn't crash due to the cookie logic.
    // 3. The URL loading is attempted (indirectly, via InAppWebView's behavior or other logs if any).
    // A full verification of `CookieManager.setCookie` calls is also not feasible here
    // without a way to mock `CookieManager.instance()`.

    // We can check that no unexpected errors (like snackbars for malformed cookies) appear if format is okay.
    expect(find.text('Error setting cookie: mycookie'), findsNothing);
    expect(find.text('Malformed cookie part'), findsNothing);
  });


  testWidgets('Header Management - Add Header', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    // Initially, one header row might be present by default
    int initialHeaderRows = find.byType(Row).evaluate().where((element) {
      final widget = element.widget as Row;
      return widget.children.any((child) => child is TextField && child.decoration?.labelText == 'Key');
    }).length;


    await tester.tap(find.widgetWithText(ElevatedButton, 'Add Header'));
    await tester.pumpAndSettle();

    int finalHeaderRows = find.byType(Row).evaluate().where((element) {
      final widget = element.widget as Row;
      return widget.children.any((child) => child is TextField && child.decoration?.labelText == 'Key');
    }).length;

    expect(finalHeaderRows, initialHeaderRows + 1, reason: "A new header row should be added");
    // Verify new row elements (e.g., two TextFields, one Checkbox, one IconButton)
    // This can be made more specific by finding unique keys if assigned to header rows
    expect(find.widgetWithText(TextField, 'Key'), findsNWidgets(finalHeaderRows));
    expect(find.widgetWithText(TextField, 'Value'), findsNWidgets(finalHeaderRows));
    expect(find.byType(Checkbox), findsNWidgets(finalHeaderRows));
    expect(find.byIcon(Icons.delete), findsNWidgets(finalHeaderRows));
  });

  testWidgets('Header Management - Edit Header Key and Value, then press Go', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    // Assuming at least one header row is present (default or added)
    // For simplicity, let's add one if none by default or make sure one exists
    final addHeaderButton = find.widgetWithText(ElevatedButton, 'Add Header');
    if (find.widgetWithText(TextField, 'Key').evaluate().isEmpty) {
        await tester.tap(addHeaderButton);
        await tester.pumpAndSettle();
    }

    final headerKeyFields = find.widgetWithText(TextField, 'Key');
    final headerValueFields = find.widgetWithText(TextField, 'Value');

    expect(headerKeyFields, findsWidgets, reason: "Should find at least one header key field");
    expect(headerValueFields, findsWidgets, reason: "Should find at least one header value field");

    await tester.enterText(headerKeyFields.first, 'X-Test-Header');
    await tester.pumpAndSettle();
    await tester.enterText(headerValueFields.first, 'TestValue123');
    await tester.pumpAndSettle();

    // To verify internal state (_headers), it's best if WebViewScreen exposes it for testing,
    // or by observing UI changes that depend on this state.
    // Directly accessing state is not typical in widget tests but can be done via GlobalKey or by finding the State object.

    // Now, tap "Go" and verify headers are used (conceptual, needs mock injection)
    await tester.enterText(find.widgetWithText(TextField, 'Enter URL'), 'https://example.com');
    await tester.tap(find.widgetWithText(ElevatedButton, 'Go'));
    await tester.pumpAndSettle();

    // Conceptual verification for loadUrl with headers:
    // final captured = verify(mockWebViewController.loadUrl(urlRequest: anyNamed('urlRequest'))).captured.single;
    // expect(captured.headers, containsPair('X-Test-Header', 'TestValue123'));
    // This requires the mock controller to be properly injected and used by InAppWebView.
  });

  testWidgets('Header Management - Enable/Disable Header', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    if (find.widgetWithText(TextField, 'Key').evaluate().isEmpty) {
        await tester.tap(find.widgetWithText(ElevatedButton, 'Add Header'));
        await tester.pumpAndSettle();
    }

    final checkboxes = find.byType(Checkbox);
    expect(checkboxes, findsWidgets, reason: "Should find checkboxes for headers");

    final firstCheckbox = checkboxes.first;
    bool initialCheckboxValue = tester.widget<Checkbox>(firstCheckbox).value ?? false;

    await tester.tap(firstCheckbox);
    await tester.pumpAndSettle();

    expect(tester.widget<Checkbox>(firstCheckbox).value, !initialCheckboxValue, reason: "Checkbox state should toggle");

    // Add URL and tap Go to see if header is included/excluded based on checkbox
    // This also requires mock injection for proper verification of headers in loadUrl.
  });

  testWidgets('Header Management - Delete Header', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    final addHeaderButton = find.widgetWithText(ElevatedButton, 'Add Header');
    await tester.tap(addHeaderButton); // Add one header to ensure there's something to delete
    await tester.pumpAndSettle();
    await tester.tap(addHeaderButton); // Add another one
    await tester.pumpAndSettle();

    int initialHeaderCount = find.byIcon(Icons.delete).evaluate().length;
    expect(initialHeaderCount, greaterThan(0), reason: "Should have headers to delete");

    await tester.tap(find.byIcon(Icons.delete).first);
    await tester.pumpAndSettle();

    expect(find.byIcon(Icons.delete), findsNWidgets(initialHeaderCount - 1), reason: "Header row should be removed");
  });

  // Note: To fully test the interactions with InAppWebViewController (like loadUrl calls with specific headers),
  // WebViewScreen would need to be refactored to allow injection of an InAppWebViewController.
  // This could be done via constructor or a provider pattern.
  // The LocalLogService would also need similar injection if its calls are to be verified.
}

// Reminder: If web_view_screen_test.mocks.dart is not generated,
// 1. Ensure `build_runner` and `mockito` are in `dev_dependencies`.
// 2. Run `flutter pub run build_runner build --delete-conflicting-outputs`.
// If that command fails in the environment, manual mocks (like MockInAppWebViewControllerManual)
// can be used, but generated mocks are preferred for accuracy and completeness.
// The LocalLogService is not mocked in these tests yet but would follow a similar pattern.
// For simplicity, LocalLogService interactions are not verified here but would be important.

// Also, the tests for "URL Input and Go button action" and "Edit Header Key and Value, then press Go"
// currently lack the direct verification of `loadUrl` arguments on the mock controller.
// This is a known limitation due to the difficulty of injecting the mock `InAppWebViewController`
// into the `InAppWebView` widget as it's constructed within `WebViewScreen`'s build method.
// A common solution is to pass the controller (or a factory for it) via the widget's constructor.
// e.g., WebViewScreen(controllerFactory: (params) => mockWebViewController)
// Or, use a state management solution that allows overriding dependencies (like Riverpod, Provider).

// The default headers (Content-Type: application/json) are also part of the initial UI.
// Tests can be expanded to check their default state and modification.
// For example, the initial header count in 'Add Header' test should account for this.
// The provided test for 'Add Header' dynamically counts existing rows to be more robust.

// The test for 'Initial UI Rendering' checks for `InAppWebView` by type. This is usually fine.
// If it fails due to platform specific rendering or other issues, one might search for a
// known parent Container or a key if assigned.
// `flutter test` environment might not fully support all native functionalities of InAppWebView,
// which is why interaction tests focus on the Flutter side (state, button taps) rather than
// actual web loading.
