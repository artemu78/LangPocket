import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:LangPocket/screens/web_view_screen.dart'; // Adjust with your actual project name
import 'package:LangPocket/services/local_log_service.dart'; // Adjust with your actual project name

// Generate mocks for InAppWebViewController and LocalLogService
// Run `flutter pub run build_runner build` to generate these files
// If build_runner is not set up, you can create manual mocks as below for now.
@GenerateMocks([InAppWebViewController, LocalLogService])
import 'web_view_screen_test.mocks.dart'; // Generated by Mockito

// Manual mock for InAppWebViewController if build_runner is not used immediately
class MockInAppWebViewControllerManual extends Mock implements InAppWebViewController {
  @override
  Future<void> loadUrl({required URLRequest urlRequest}) async {
    // Allow capturing arguments or defining behavior
    super.noSuchMethod(
      Invocation.method(#loadUrl, [], {#urlRequest: urlRequest}),
      returnValue: Future.value(null),
      returnValueForMissingStub: Future.value(null)
    );
  }
}

// Manual mock for LocalLogService
class MockLocalLogServiceManual extends Mock implements LocalLogService {
  List<Map<String, dynamic>> loggedErrors = [];
  List<String> logs = []; // To capture generic logs if any were still using a generic method

  @override
  Future<void> logErrorLocal(
    String message, {
    Object? error,
    StackTrace? stackTrace,
  }) async {
    loggedErrors.add({
      'message': message,
      'error': error,
      'stackTrace': stackTrace,
    });
    // Simulate async operation if the real one is async
    // For testing, direct call might be fine.
    // super.noSuchMethod(Invocation.method(#logErrorLocal, [message], {#error: error, #stackTrace: stackTrace}), returnValue: Future.value(null));
  }

  // Implementing other methods from LocalLogService interface as stubs or with basic tracking if needed by tests
  // For now, assuming only logErrorLocal is actively used and verified from WebViewScreen.
  // The original LocalLogService had addLog, log, getLogs, getLogCount, purgeLogs.
  // If WebViewScreen doesn't call them, their mocks aren't strictly needed for these tests.

  // Deprecated/Old methods (if any test still relies on them by mistake, or for broader interface compliance)
  @override
  void addLog(String level, String message) { // This was the old method
    logs.add('$level: $message');
    // super.noSuchMethod(Invocation.method(#addLog, [level, message]));
  }

  @override
  void log(String message) { // This was a very old method
    logs.add(message);
    // super.noSuchMethod(Invocation.method(#log, [message]));
  }

  @override
  Future<List<Map<String, dynamic>>> getLogs() async {
    // Return a representation of loggedErrors or other logs if needed for a test
    return Future.value(loggedErrors);
  }

  @override
  Future<int> getLogCount() async {
    return Future.value(loggedErrors.length);
  }

  @override
  Future<void> purgeLogs() async {
    loggedErrors.clear();
    logs.clear();
  }
}

// Manual mock for CookieManager
class MockCookieManager extends Mock implements CookieManager {
  @override
  Future<bool> setCookie({
    required WebUri url,
    required String name,
    required String value,
    String path = "/",
    String? domain,
    int? expiresDate,
    int? maxAge,
    bool? isSecure,
    bool? isHttpOnly,
    SameSite? sameSite,
  }) async {
    return super.noSuchMethod(
      Invocation.method(#setCookie, [], {
        #url: url,
        #name: name,
        #value: value,
        #path: path,
        #domain: domain,
        #expiresDate: expiresDate,
        #maxAge: maxAge,
        #isSecure: isSecure,
        #isHttpOnly: isHttpOnly,
        #sameSite: sameSite,
      }),
      returnValue: Future.value(true), // Default to true for successful set
      returnValueForMissingStub: Future.value(true),
    );
  }
}


void main() {
  TestWidgetsFlutterBinding.ensureInitialized(); // Ensure binding is initialized


  // Helper function to find a specific header row and check its checkbox
  Future<void> expectHeaderEnabled(WidgetTester tester, String headerKey, String headerValue, bool isEnabled) async {
    // Find TextFormFields for key and value to locate the row.
    expect(find.widgetWithText(TextFormField, headerKey), findsOneWidget, reason: 'TextFormField for key "$headerKey" should be present.');
    expect(find.widgetWithText(TextFormField, headerValue), findsOneWidget, reason: 'TextFormField for value "$headerValue" should be present.');

    // Find the Row that contains this header key.
    final headerKeyFieldFinder = find.widgetWithText(TextFormField, headerKey);
    final rowFinder = find.ancestor(
      of: headerKeyFieldFinder,
      matching: find.byType(Row),
    );
    expect(rowFinder, findsOneWidget, reason: 'Row containing header "$headerKey" should be found.');

    // Within that Row, find the Checkbox and check its state.
    final checkboxFinder = find.descendant(
      of: rowFinder,
      matching: find.byType(Checkbox),
    );
    expect(checkboxFinder, findsOneWidget, reason: 'Checkbox in row for header "$headerKey" should be found.');
    final Checkbox checkboxWidget = tester.widget<Checkbox>(checkboxFinder);
    expect(checkboxWidget.value, isEnabled, reason: 'Checkbox for header "$headerKey" should be ${isEnabled ? 'checked' : 'unchecked'}.');
  }

  late MockInAppWebViewController mockWebViewController;
  late MockLocalLogServiceManual mockLogService; // Use the manual mock for LocalLogService
  // late MockCookieManager mockCookieManager; // Instance for CookieManager

  setUp(() {
    mockWebViewController = MockInAppWebViewController();
    mockLogService = MockLocalLogServiceManual();
    // mockCookieManager = MockCookieManager();

    // WebViewScreen instantiates its own LocalLogService.
    // To verify log calls, WebViewScreen would need to accept LocalLogService via constructor.
    // For CookieManager, it uses CookieManager.instance(). Mocking this static getter
    // is complex without library support for it (like `CookieManager.instance = mockCookieManager;`)
    // which flutter_inappwebview does not seem to offer directly for tests.

    when(mockWebViewController.loadUrl(urlRequest: anyNamed('urlRequest')))
        .thenAnswer((_) async {});
  });

  // Helper function to pump the widget
  Future<void> pumpWebViewScreen(WidgetTester tester, {LocalLogService? logService}) async {
    await tester.pumpWidget(MaterialApp(
      // If WebViewScreen were refactored to take LocalLogService or CookieManager:
      // home: WebViewScreen(logService: logService ?? MockLocalLogServiceManual()),
      home: const WebViewScreen(), // Current implementation
    ));
    await tester.pumpAndSettle();
  }

  testWidgets('Initial UI Rendering (including Cookie TextField and Default Headers)', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    expect(find.text('Web View'), findsOneWidget, reason: "AppBar title should be 'Web View'");
    expect(find.widgetWithText(TextField, 'Enter URL'), findsOneWidget, reason: "URL input TextField should be present");
    expect(find.widgetWithText(ElevatedButton, 'Go'), findsOneWidget, reason: "'Go' button should be present");
    expect(find.widgetWithText(ElevatedButton, 'Add Header'), findsOneWidget, reason: "'Add Header' button should be present");
    expect(find.byType(InAppWebView), findsOneWidget, reason: "InAppWebView widget should be present");

    // Verify Cookie TextField presence
    expect(find.widgetWithText(TextField, 'Enter cookie values (e.g., name1=value1; name2=value2)'), findsOneWidget, reason: "Cookie input TextField should be present");

    // Verify default headers
    await expectHeaderEnabled(tester, 'User-Agent', 'LangPocketWebView/1.0', true);
    await expectHeaderEnabled(tester, 'x-zalando-entity-id', 'checkoutconfirm', true);
    await expectHeaderEnabled(tester, 'x-re-hints', 'checkout-confirm', true);
    await expectHeaderEnabled(tester, 'x-zalando-entity-type', 'checkoutcontract', true);
    await expectHeaderEnabled(tester, 'x-zalando-feature', 'checkout-confirm', true);
    await expectHeaderEnabled(tester, 'x-device-type', 'mobile', true);
    await expectHeaderEnabled(tester, 'x-re-webview', 'true', true);
    await expectHeaderEnabled(tester, 'x-zalando-client-id', 'dca76205-a22c-4d70-a346-87c2b6442954', true);
  });

  testWidgets('Entering text in Cookie TextField updates its controller', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    final cookieFieldFinder = find.widgetWithText(TextField, 'Enter cookie values (e.g., name1=value1; name2=value2)');
    expect(cookieFieldFinder, findsOneWidget);

    await tester.enterText(cookieFieldFinder, 'user=test; token=abc');
    await tester.pumpAndSettle();

    final textField = tester.widget<TextField>(cookieFieldFinder);
    expect(textField.controller?.text, 'user=test; token=abc');
  });

  testWidgets('URL Input, Cookie Input, and Go button action - with error in cookie setting', (WidgetTester tester) async {
    // This test relies on the fact that WebViewScreen creates its own LocalLogService instance.
    // We can't inject a mock directly to use verify().
    // Instead, we could expose the LocalLogService instance from WebViewScreen's state for testing,
    // or use a global service locator that can be configured for tests.
    // For now, this test will check for UI feedback (like SnackBars) and assume error logging happens.

    await pumpWebViewScreen(tester);

    final urlField = find.widgetWithText(TextField, 'Enter URL');
    await tester.enterText(urlField, 'https://example.com'); // Valid URL for cookie domain

    // Malformed cookie string (e.g., missing value, or a problematic character if parser is strict)
    // The current parser splits by '=' and expects two parts. "badcookie;" will result in one part.
    // "badcookie=" will result in two parts, but value is empty.
    // Let's test a case that causes an error in setCookie itself, e.g. by a name that's rejected.
    // However, our mock CookieManager above doesn't simulate setCookie errors.
    // For this test, let's assume that the SnackBar for "Error setting cookie" is a primary indicator.

    // To test the logErrorLocal path for cookie setting, we'd need to make CookieManager.setCookie throw.
    // This is hard with the static instance.
    // Let's test the scenario where the URL is invalid for cookies (no host).
    await tester.enterText(urlField, 'notaurl'); // Invalid URL, no host
    final cookieField = find.widgetWithText(TextField, 'Enter cookie values (e.g., name1=value1; name2=value2)');
    await tester.enterText(cookieField, 'mycookie=myvalue');

    await tester.tap(find.widgetWithText(ElevatedButton, 'Go'));
    await tester.pumpAndSettle();

    // Previously, this test checked for absence of "Error setting cookie" snackbar.
    // Now, we expect a snackbar for "URL has no host".
    // The logging for "URL has no host" is now a print statement, not verifiable here.
    // The SnackBar "URL has no host, cannot set cookies." should appear.
    expect(find.text('URL has no host, cannot set cookies.'), findsOneWidget);

    // If we wanted to verify logErrorLocal for "Failed to set cookie", we would need to:
    // 1. Refactor WebViewScreen to take LocalLogService as a dependency.
    // 2. Provide the mockLogService to it.
    // 3. Configure the (mocked) CookieManager to throw an error when setCookie is called.
    // Then: expect(mockLogService.loggedErrors.any((log) => log['message'].contains('Failed to set cookie')), isTrue);
  });


  testWidgets('Header Management - Add Header', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    // Initially, one header row might be present by default
    int initialHeaderRows = find.byType(Row).evaluate().where((element) {
      final widget = element.widget as Row;
      return widget.children.any((child) => child is TextField && child.decoration?.labelText == 'Key');
    }).length;


    await tester.tap(find.widgetWithText(ElevatedButton, 'Add Header'));
    await tester.pumpAndSettle();

    int finalHeaderRows = find.byType(Row).evaluate().where((element) {
      final widget = element.widget as Row;
      return widget.children.any((child) => child is TextField && child.decoration?.labelText == 'Key');
    }).length;

    expect(finalHeaderRows, initialHeaderRows + 1, reason: "A new header row should be added");
    // Verify new row elements (e.g., two TextFields, one Checkbox, one IconButton)
    // This can be made more specific by finding unique keys if assigned to header rows
    expect(find.widgetWithText(TextField, 'Key'), findsNWidgets(finalHeaderRows));
    expect(find.widgetWithText(TextField, 'Value'), findsNWidgets(finalHeaderRows));
    expect(find.byType(Checkbox), findsNWidgets(finalHeaderRows));
    expect(find.byIcon(Icons.delete), findsNWidgets(finalHeaderRows));
  });

  testWidgets('Header Management - Edit Header Key and Value, then press Go', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    // Assuming at least one header row is present (default or added)
    // For simplicity, let's add one if none by default or make sure one exists
    final addHeaderButton = find.widgetWithText(ElevatedButton, 'Add Header');
    if (find.widgetWithText(TextField, 'Key').evaluate().isEmpty) {
        await tester.tap(addHeaderButton);
        await tester.pumpAndSettle();
    }

    final headerKeyFields = find.widgetWithText(TextField, 'Key');
    final headerValueFields = find.widgetWithText(TextField, 'Value');

    expect(headerKeyFields, findsWidgets, reason: "Should find at least one header key field");
    expect(headerValueFields, findsWidgets, reason: "Should find at least one header value field");

    await tester.enterText(headerKeyFields.first, 'X-Test-Header');
    await tester.pumpAndSettle();
    await tester.enterText(headerValueFields.first, 'TestValue123');
    await tester.pumpAndSettle();

    // To verify internal state (_headers), it's best if WebViewScreen exposes it for testing,
    // or by observing UI changes that depend on this state.
    // Directly accessing state is not typical in widget tests but can be done via GlobalKey or by finding the State object.

    // Now, tap "Go" and verify headers are used (conceptual, needs mock injection)
    await tester.enterText(find.widgetWithText(TextField, 'Enter URL'), 'https://example.com');
    await tester.tap(find.widgetWithText(ElevatedButton, 'Go'));
    await tester.pumpAndSettle();

    // Conceptual verification for loadUrl with headers:
    // final captured = verify(mockWebViewController.loadUrl(urlRequest: anyNamed('urlRequest'))).captured.single;
    // expect(captured.headers, containsPair('X-Test-Header', 'TestValue123'));
    // This requires the mock controller to be properly injected and used by InAppWebView.
  });

  testWidgets('Header Management - Enable/Disable Header', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    if (find.widgetWithText(TextField, 'Key').evaluate().isEmpty) {
        await tester.tap(find.widgetWithText(ElevatedButton, 'Add Header'));
        await tester.pumpAndSettle();
    }

    final checkboxes = find.byType(Checkbox);
    expect(checkboxes, findsWidgets, reason: "Should find checkboxes for headers");

    final firstCheckbox = checkboxes.first;
    bool initialCheckboxValue = tester.widget<Checkbox>(firstCheckbox).value ?? false;

    await tester.tap(firstCheckbox);
    await tester.pumpAndSettle();

    expect(tester.widget<Checkbox>(firstCheckbox).value, !initialCheckboxValue, reason: "Checkbox state should toggle");

    // Add URL and tap Go to see if header is included/excluded based on checkbox
    // This also requires mock injection for proper verification of headers in loadUrl.
  });

  testWidgets('Header Management - Delete Header', (WidgetTester tester) async {
    await pumpWebViewScreen(tester);

    final addHeaderButton = find.widgetWithText(ElevatedButton, 'Add Header');
    await tester.tap(addHeaderButton); // Add one header to ensure there's something to delete
    await tester.pumpAndSettle();
    await tester.tap(addHeaderButton); // Add another one
    await tester.pumpAndSettle();

    int initialHeaderCount = find.byIcon(Icons.delete).evaluate().length;
    expect(initialHeaderCount, greaterThan(0), reason: "Should have headers to delete");

    await tester.tap(find.byIcon(Icons.delete).first);
    await tester.pumpAndSettle();

    expect(find.byIcon(Icons.delete), findsNWidgets(initialHeaderCount - 1), reason: "Header row should be removed");
  });

  // Note: To fully test the interactions with InAppWebViewController (like loadUrl calls with specific headers),
  // WebViewScreen would need to be refactored to allow injection of an InAppWebViewController.
  // This could be done via constructor or a provider pattern.
  // The LocalLogService would also need similar injection if its calls are to be verified.
}

// Reminder: If web_view_screen_test.mocks.dart is not generated,
// 1. Ensure `build_runner` and `mockito` are in `dev_dependencies`.
// 2. Run `flutter pub run build_runner build --delete-conflicting-outputs`.
// If that command fails in the environment, manual mocks (like MockInAppWebViewControllerManual)
// can be used, but generated mocks are preferred for accuracy and completeness.
// The LocalLogService is not mocked in these tests yet but would follow a similar pattern.
// For simplicity, LocalLogService interactions are not verified here but would be important.

// Also, the tests for "URL Input and Go button action" and "Edit Header Key and Value, then press Go"
// currently lack the direct verification of `loadUrl` arguments on the mock controller.
// This is a known limitation due to the difficulty of injecting the mock `InAppWebViewController`
// into the `InAppWebView` widget as it's constructed within `WebViewScreen`'s build method.
// A common solution is to pass the controller (or a factory for it) via the widget's constructor.
// e.g., WebViewScreen(controllerFactory: (params) => mockWebViewController)
// Or, use a state management solution that allows overriding dependencies (like Riverpod, Provider).

// The default headers (Content-Type: application/json) are also part of the initial UI.
// Tests can be expanded to check their default state and modification.
// For example, the initial header count in 'Add Header' test should account for this.
// The provided test for 'Add Header' dynamically counts existing rows to be more robust.

// The test for 'Initial UI Rendering' checks for `InAppWebView` by type. This is usually fine.
// If it fails due to platform specific rendering or other issues, one might search for a
// known parent Container or a key if assigned.
// `flutter test` environment might not fully support all native functionalities of InAppWebView,
// which is why interaction tests focus on the Flutter side (state, button taps) rather than
// actual web loading.
